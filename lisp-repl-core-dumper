#!/bin/sh
#| -*- mode: lisp; -*-
## Copyright (C) 2020, 2021 Pierre Neidhardt <mail@ambrevar.xyz>
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

version="0.4.0"

XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
LISP_REPL_CORE_PATH=${LISP_REPL_CORE_PATH:-$XDG_CACHE_HOME/lisp-repl-core-directory}

error_args=1
error_generation=2

usage () {
	cat<<EOF>&2
Usage: ${0##*/} LISP [START-FLAGS]

Create (if necessary) a Lisp executable image with ASDF preloaded, then run this
image and pass it START-FLAGS.

Options:

  -c: Clear ASDF configuration on image start.  This slows down startup a little
      but without it you'd have to run '(asdf:clear-configuration)' to reflect
      changes made after the image generation.

  -f: Force rebuild the image.  This is useful for instance if you've updated
      the systems.

  -g FLAGS: Command line arguments to pass to the Lisp when generating the
            image.  Instead of evaluating Lisp directly from the flags
            (e.g. with --eval), it's recommended to load a Lisp file containing
            the desired code.

  -p PACKAGES: Preload the whitespace-separated list of packages into the image.

  -v: Show version and exit.

The image is only created for one of the following reasons:

- If it does not exist.
- If its version does not match LISP version.
- If its preloaded systems do not match SYSTEMS.

The image is stored in \$LISP_REPL_CORE_PATH
($LISP_REPL_CORE_PATH).
EOF
}

opt_force=false
opt_clear_asdf=false
opt_user_gen_flags=""
opt_user_packages=""
while getopts ":chfg:p:uv" opt; do
	case $opt in
	c)
		opt_clear_asdf=true ;;
	h)
		usage
		exit 0 ;;
	f)
		opt_force=true ;;
	g)
		opt_user_gen_flags="$OPTARG" ;;
	p)
		if [ -z "$opt_user_packages" ]; then
			opt_user_packages="$OPTARG"
		else
			opt_user_packages="$opt_user_packages $OPTARG"
		fi ;;
	v)
		echo $version
		exit 0 ;;
	\?)
		usage
		exit 1 ;;
	esac
done

shift $(($OPTIND - 1))
[ $# -eq 0 ] && usage && exit $error_args

scriptpath=$0
lisp=$1
lisp_basename=$(basename "$lisp")
shift 1
packages=$(echo "$opt_user_packages" | sed 's/ /\n/g' | sort | paste -sd '+' -)
[ -n "$packages" ] && packages=-"$packages"

case "$lisp_basename" in
sbcl)
	version_flags="--noinform --no-userinit"
	eval_flag=--eval
	;;
ccl)
	version_flags=--no-init
	eval_flag=--eval
	;;
clisp)
	version_flags="-norc --quiet"
	eval_flag=-x
	;;
	*)
		echo >&2 "Unsupported '$lisp' implementation, falling back to original executable."
		exec "$lisp"
		;;
esac

## TODO: Include tests here?

## Wrap result with (progn ... (values)) because CLISP outputs `-x` evalutions
## to stdout.
version=$("$lisp" $version_flags $eval_flag '(progn (princ (lisp-implementation-version)) (values))' $eval_flag '(quit)')
core="$LISP_REPL_CORE_PATH"/$lisp_basename-$version$packages.image

gencore () {
	$opt_clear_asdf && export LISP_REPL_CLEAR_ASDF=true
	case "$lisp_basename" in
	sbcl)
		## While `--script' is useful to skip the #! line but it disables the init
		## files and the debugger.
		## - The user init is important to support user setups like Quicklisp.
		## - The debugger is important to avoid exitting the REPL on error.
		## We load the file manually instead.
		$lisp $opt_user_gen_flags $eval_flag \
					"$(cat<<EOF
(with-open-file (s "$scriptpath")
  (read-line s)
  (load s))
EOF
)" "$core" "$@"
		;;
	ccl)
		## It seems that CCL cannot load files with shabangs and
		##   (progn (read-line s) (load s))
		## does not seem to work.
		$lisp $opt_user_gen_flags $eval_flag \
					"$(cat<<EOF
(with-open-file (s "$scriptpath")
  (read-line s)
  (let ((file-string (format nil "~{~a~^~%~}"
                             (loop for line = (read-line s nil :eof)
                                   until (eq line :eof)
                                   collect line))))
    (with-input-from-string (s file-string)
      (loop for object = (read s nil :eof)
            until (eq object :eof)
            do (eval object)))))
EOF
						)" -- "$core" "$@"
		;;
	clisp)
		$lisp $opt_user_gen_flags "$scriptpath" -- "$core" "$@"
		;;
	esac
	## Newline for clearer output.
	echo
}

if $opt_force || [ ! -f "$core" ]; then
	## We intentionally unquote $opt_user_packages so that they are word-splitted.
	gencore $opt_user_packages
fi

if [ -f "$core" ]; then
	## We can't `exec' here because we need to check for errors.
	echo >&2 "Running '$core'."
	exec "$core" "$@"
else
	echo >&2 "Error generating image."
	exit $error_generation
fi

|#
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(require "asdf")

(let ((default-packages (append
                         #+sbcl
                         '(sb-bsd-sockets sb-posix sb-introspect sb-cltl2)
                         '(asdf)))
      (core (first (uiop:command-line-arguments)))
      (extra-packages (rest (uiop:command-line-arguments))))
  (mapc #'require default-packages)
  (mapc #'asdf:load-system extra-packages)

  (format *error-output* "Dumping...~%")
  (finish-output *error-output*)
  (format t "~a~%" core)
  (finish-output)

  ;; `*image-dump-hook*' is `(UIOP/CONFIGURATION:CLEAR-CONFIGURATION)' by
  ;; default, which slows down startup.
  (unless (uiop:getenv "LISP_REPL_CLEAR_ASDF")
    (setf uiop:*image-dump-hook* nil))

  (uiop:ensure-all-directories-exist
   (list (directory-namestring core)))

  #-clisp
  (uiop:dump-image core)
  #+clisp
  (progn
    ;; CLISP image saving is too verbose.
    (funcall (read-from-string "uiop:call-with-null-output")
             (lambda (null-output)
               (let ((*standard-output* null-output))
                 (ext:saveinitmem core
                                  :quiet t
                                  :start-package *package*
                                  :keep-global-handlers nil
                                  :executable t))))
    ;; CLISP does not quit after dumping an image.
    (ext:quit 0)))
